//
//  NoZ - Copyright(c) 2026 NoZ Games, LLC
//

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace NoZ.Generators;

[Generator]
public class SkinGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes with [Skinnable] attribute
        var classDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "NoZ.SkinnableAttribute",
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetSkinnableInfo(ctx))
            .Where(static info => info is not null);

        context.RegisterSourceOutput(classDeclarations, static (ctx, info) => GenerateSource(ctx, info!));
    }

    private static SkinnableInfo? GetSkinnableInfo(GeneratorAttributeSyntaxContext context)
    {
        var symbol = context.TargetSymbol as INamedTypeSymbol;
        if (symbol is null) return null;

        var fields = new List<SkinFieldInfo>();
        var skinNames = new HashSet<string>();
        string? defaultSkin = null;

        // Recursively walk nested types to find fields with [Skin] attributes
        CollectSkinFields(symbol, new List<string>(), fields, skinNames, ref defaultSkin);

        if (fields.Count == 0) return null;

        // If no default was specified, use the first skin name found
        if (defaultSkin == null && skinNames.Count > 0)
            defaultSkin = skinNames.First();

        return new SkinnableInfo
        {
            Namespace = symbol.ContainingNamespace.ToDisplayString(),
            ClassName = symbol.Name,
            Fields = fields,
            SkinNames = skinNames.OrderBy(n => n).ToList(),
            DefaultSkin = defaultSkin ?? "Default"
        };
    }

    private static void CollectSkinFields(
        INamedTypeSymbol type,
        List<string> nestedPath,
        List<SkinFieldInfo> fields,
        HashSet<string> skinNames,
        ref string? defaultSkin)
    {
        // Check fields in this type
        foreach (var member in type.GetMembers())
        {
            if (member is IFieldSymbol field)
            {
                var overrides = new List<SkinOverride>();
                foreach (var attr in field.GetAttributes())
                {
                    if (attr.AttributeClass?.ToDisplayString() != "NoZ.SkinAttribute")
                        continue;

                    if (attr.ConstructorArguments.Length < 2)
                        continue;

                    string skinName, propName, value;
                    if (attr.ConstructorArguments.Length >= 3)
                    {
                        skinName = attr.ConstructorArguments[0].Value?.ToString() ?? "";
                        propName = attr.ConstructorArguments[1].Value?.ToString() ?? "";
                        value = attr.ConstructorArguments[2].Value?.ToString() ?? "";
                    }
                    else
                    {
                        // 2-arg: (skinName, value) â€” direct field assignment
                        skinName = attr.ConstructorArguments[0].Value?.ToString() ?? "";
                        propName = "";
                        value = attr.ConstructorArguments[1].Value?.ToString() ?? "";
                    }

                    if (string.IsNullOrEmpty(skinName))
                        continue;

                    skinNames.Add(skinName);
                    overrides.Add(new SkinOverride
                    {
                        SkinName = skinName,
                        PropertyName = propName,
                        Value = value
                    });
                }

                if (overrides.Count > 0)
                {
                    fields.Add(new SkinFieldInfo
                    {
                        NestedPath = new List<string>(nestedPath),
                        FieldName = field.Name,
                        Overrides = overrides
                    });
                }
            }
        }

        // Recurse into nested types
        foreach (var member in type.GetTypeMembers())
        {
            nestedPath.Add(member.Name);
            CollectSkinFields(member, nestedPath, fields, skinNames, ref defaultSkin);
            nestedPath.RemoveAt(nestedPath.Count - 1);
        }
    }

    private static void GenerateSource(SourceProductionContext context, SkinnableInfo info)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(info.Namespace) && info.Namespace != "<global namespace>")
        {
            sb.AppendLine($"namespace {info.Namespace};");
            sb.AppendLine();
        }

        sb.AppendLine("using NoZ;");
        sb.AppendLine();
        sb.AppendLine($"partial class {info.ClassName}");
        sb.AppendLine("{");

        // Generate Skins class with const names
        sb.AppendLine("    public static class Skins");
        sb.AppendLine("    {");
        foreach (var name in info.SkinNames)
        {
            sb.AppendLine($"        public const string {name} = \"{name}\";");
        }
        sb.AppendLine("    }");
        sb.AppendLine();

        // CurrentSkin property
        sb.AppendLine($"    public static string CurrentSkin {{ get; private set; }}");
        sb.AppendLine();

        // SetSkin method
        sb.AppendLine("    public static void SetSkin(string name)");
        sb.AppendLine("    {");
        sb.AppendLine("        CurrentSkin = name;");

        bool first = true;
        foreach (var skinName in info.SkinNames)
        {
            var prefix = first ? "if" : "else if";
            sb.AppendLine($"        {prefix} (name == Skins.{skinName})");
            sb.AppendLine("        {");

            foreach (var field in info.Fields)
            {
                foreach (var ov in field.Overrides.Where(o => o.SkinName == skinName))
                {
                    var path = field.NestedPath.Count > 0
                        ? string.Join(".", field.NestedPath) + "." + field.FieldName
                        : field.FieldName;

                    var colorExpr = ParseColorValue(ov.Value);
                    if (string.IsNullOrEmpty(ov.PropertyName))
                        sb.AppendLine($"            {path} = {colorExpr};");
                    else
                        sb.AppendLine($"            {path}.{ov.PropertyName} = {colorExpr};");
                }
            }

            sb.AppendLine("        }");
            first = false;
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource($"{info.ClassName}.Skin.g.cs", sb.ToString());
    }

    private static string ParseColorValue(string value)
    {
        // Handle hex color strings: #RRGGBB or #RRGGBBAA
        if (value.StartsWith("#") && (value.Length == 7 || value.Length == 9))
        {
            var hex = value.Substring(1);
            if (hex.Length == 6)
                return $"Color.FromRgb(0x{hex})";
            else
                return $"Color.FromRgba(0x{hex})";
        }

        // Fallback: emit as-is
        return value;
    }

    private class SkinOverride
    {
        public string SkinName { get; set; } = "";
        public string PropertyName { get; set; } = "";
        public string Value { get; set; } = "";
    }

    private class SkinFieldInfo
    {
        public List<string> NestedPath { get; set; } = new();
        public string FieldName { get; set; } = "";
        public List<SkinOverride> Overrides { get; set; } = new();
    }

    private class SkinnableInfo
    {
        public string Namespace { get; set; } = "";
        public string ClassName { get; set; } = "";
        public List<SkinFieldInfo> Fields { get; set; } = new();
        public List<string> SkinNames { get; set; } = new();
        public string DefaultSkin { get; set; } = "";
    }
}
