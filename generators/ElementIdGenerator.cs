//
//  NoZ - Copyright(c) 2026 NoZ Games, LLC
//

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace NoZ.Generators;

[Generator]
public class ElementIdGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes with [ElementId] attributes
        var classDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "NoZ.ElementIdAttribute",
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetClassInfo(ctx))
            .Where(static info => info is not null);

        // Extract the range start from [assembly: ElementIdRange(start, end)]
        var rangeStart = context.CompilationProvider.Select(static (compilation, _) =>
        {
            foreach (var attr in compilation.Assembly.GetAttributes())
            {
                if (attr.AttributeClass?.Name == "ElementIdRangeAttribute" &&
                    attr.ConstructorArguments.Length >= 1 &&
                    attr.ConstructorArguments[0].Value is int start)
                {
                    return start;
                }
            }
            return 1;
        });

        // Combine class infos with range start
        var combined = classDeclarations.Collect().Combine(rangeStart);

        context.RegisterSourceOutput(combined, GenerateSource);
    }

    private static ClassInfo? GetClassInfo(GeneratorAttributeSyntaxContext context)
    {
        var symbol = context.TargetSymbol as INamedTypeSymbol;
        if (symbol is null) return null;

        // Collect all ElementId attributes
        var fields = new List<FieldInfo>();
        foreach (var attr in context.Attributes)
        {
            var name = attr.ConstructorArguments.Length > 0
                ? attr.ConstructorArguments[0].Value?.ToString() ?? ""
                : "";

            if (string.IsNullOrEmpty(name))
                continue;

            var count = 1;
            if (attr.ConstructorArguments.Length > 1 &&
                attr.ConstructorArguments[1].Value is int c)
            {
                count = c;
            }

            fields.Add(new FieldInfo { Name = name, Count = count });
        }

        if (fields.Count == 0)
            return null;

        // Build the containing type chain for nested classes
        var containingTypes = new List<string>();
        var current = symbol.ContainingType;
        while (current != null)
        {
            containingTypes.Insert(0, current.Name);
            current = current.ContainingType;
        }

        return new ClassInfo
        {
            Namespace = symbol.ContainingNamespace.ToDisplayString(),
            ClassName = symbol.Name,
            Fields = fields,
            ContainingTypes = containingTypes
        };
    }

    private static void GenerateSource(
        SourceProductionContext context,
        (ImmutableArray<ClassInfo?> Classes, int RangeStart) input)
    {
        // Sort by full type path to ensure deterministic ID assignment
        var validClasses = input.Classes
            .Where(c => c is not null)
            .Cast<ClassInfo>()
            .OrderBy(c => c.Namespace)
            .ThenBy(c => string.Join(".", c.ContainingTypes))
            .ThenBy(c => c.ClassName)
            .ToList();

        int nextId = input.RangeStart;

        foreach (var classInfo in validClasses)
        {
            var source = GenerateClass(classInfo, ref nextId);

            var fileName = classInfo.ContainingTypes.Count > 0
                ? $"{string.Join(".", classInfo.ContainingTypes)}.{classInfo.ClassName}.g.cs"
                : $"{classInfo.ClassName}.g.cs";

            context.AddSource(fileName, source);
        }
    }

    private static string GenerateClass(ClassInfo info, ref int nextId)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(info.Namespace) && info.Namespace != "<global namespace>")
        {
            sb.AppendLine($"namespace {info.Namespace};");
            sb.AppendLine();
        }

        // Open containing types
        var indent = "";
        foreach (var containingType in info.ContainingTypes)
        {
            sb.AppendLine($"{indent}partial class {containingType}");
            sb.AppendLine($"{indent}{{");
            indent += "    ";
        }

        // The target class
        sb.AppendLine($"{indent}static partial class {info.ClassName}");
        sb.AppendLine($"{indent}{{");
        indent += "    ";

        // Generate const fields
        foreach (var field in info.Fields)
        {
            sb.AppendLine($"{indent}public const int {field.Name} = {nextId};");
            nextId += field.Count;
        }

        // Close the target class
        indent = indent.Substring(4);
        sb.AppendLine($"{indent}}}");

        // Close containing types
        foreach (var _ in info.ContainingTypes)
        {
            indent = indent.Substring(4);
            sb.AppendLine($"{indent}}}");
        }

        return sb.ToString();
    }

    private class FieldInfo
    {
        public string Name { get; set; } = "";
        public int Count { get; set; } = 1;
    }

    private class ClassInfo
    {
        public string Namespace { get; set; } = "";
        public string ClassName { get; set; } = "";
        public List<FieldInfo> Fields { get; set; } = new();
        public List<string> ContainingTypes { get; set; } = new();
    }
}
