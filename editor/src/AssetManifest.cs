//
//  NoZ - Copyright(c) 2026 NoZ Games, LLC
//

namespace NoZ.Editor;

public static class AssetManifest
{
    public static bool IsModified { get; set; }

    public static void Generate(bool force=false)
    {
        if (!force && !IsModified)
            return;

        IsModified = false;

        var config = EditorApplication.Config;

        if (config.GenerateCs != null)
            GenerateCs(config);

        if (config.GenerateLua != null)
            GenerateLua(config);

        DocumentManager.DocumentAdded += doc => { IsModified = true; };
    }

    private static string GetAssetTypeName(AssetType type)
        => Asset.GetDef(type)?.Name ?? type.ToString();

    private static string GetAssetTypeExpr(AssetType type)
    {
        var def = Asset.GetDef(type);
        if (def == null)
            return $"AssetType.FromString(\"{type}\")";

        // Check if AssetType has a built-in static field for this type
        var field = typeof(AssetType).GetField(def.Name, System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);
        if (field != null)
            return $"AssetType.{def.Name}";

        // Custom asset type: use the runtime type's Type field
        return $"{def.RuntimeType.Name}.Type";
    }

    private static string Pluralize(string typeName)
    {
        if (typeName.EndsWith("s", StringComparison.Ordinal))
            return typeName + "es";
        return typeName + "s";
    }

    private static List<(AssetType Type, Document Doc)> GetManifestEntries()
    {
        var entries = new List<(AssetType Type, Document Doc)>();

        // Collect actual sprite names for conflict detection
        var spriteNames = new HashSet<string>();
        foreach (var doc in DocumentManager.Documents)
        {
            if (doc.IsEditorOnly) continue;
            if (doc.Def.Type == AssetType.Sprite)
                spriteNames.Add(doc.Name);
        }

        foreach (var doc in DocumentManager.Documents)
        {
            if (doc.IsEditorOnly) continue;

            // Texture documents marked as sprites get remapped
            if (doc is TextureDocument { IsSprite: true } texDoc)
            {
                if (spriteNames.Contains(texDoc.Name))
                {
                    Log.Warning($"Texture sprite '{texDoc.Name}' conflicts with sprite '{texDoc.Name}', skipping from manifest");
                    continue;
                }
                entries.Add((AssetType.Sprite, doc));
                continue;
            }

            entries.Add((doc.Def.Type, doc));
        }

        return entries;
    }

    private static void GenerateCs(EditorConfig config)
    {
        var path = config.GenerateCs!;
        Directory.CreateDirectory(Path.GetDirectoryName(path) ?? ".");

        using var writer = new StreamWriter(path);

        writer.WriteLine("//");
        writer.WriteLine("//  Auto-generated by NoZ Editor - DO NOT EDIT");
        writer.WriteLine("//");
        writer.WriteLine();
        writer.WriteLine("using NoZ;");
        writer.WriteLine();
        writer.WriteLine($"namespace {config.CsNamespace};");
        writer.WriteLine();
        writer.WriteLine($"public static class {config.CsClass}");
        writer.WriteLine("{");

        var manifestEntries = GetManifestEntries();
        var documentsByType = manifestEntries
            .GroupBy(e => e.Type)
            .OrderBy(g => g.Key.ToString())
            .Select(g => new { Key = g.Key, Docs = g.Select(e => e.Doc).ToList() })
            .ToList();

        var hasAtlases = documentsByType.Any(g => g.Key == AssetType.Atlas);

        // Names class (deduplicated since different types can share names)
        writer.WriteLine("    public static class Names");
        writer.WriteLine("    {");
        var uniqueNames = documentsByType
            .SelectMany(g => g.Docs)
            .Select(d => d.Name)
            .Distinct()
            .OrderBy(n => n);
        foreach (var name in uniqueNames)
        {
            var constName = ToPascalCase(name);
            writer.WriteLine($"        public const string {constName} = \"{name}\";");
        }
        writer.WriteLine("    }");

        // Layers class for sprite layer constants
        var spriteLayers = config.SpriteLayers;
        if (spriteLayers.Length > 0)
        {
            writer.WriteLine();
            writer.WriteLine("    public static class Layers");
            writer.WriteLine("    {");
            foreach (var layer in spriteLayers.OrderBy(l => l.Layer))
            {
                var constName = ToCSharpIdentifier(layer.Id);
                writer.WriteLine($"        public const ushort {constName} = {layer.Layer};");
            }
            writer.WriteLine("    }");
        }

        // Static classes grouped by type, each with Load() and Unload() methods
        foreach (var group in documentsByType)
        {
            var typeName = GetAssetTypeName(group.Key);
            var pluralName = Pluralize(typeName);
            var runtimeType = Asset.GetDef(group.Key)?.RuntimeType.Name ?? "Asset";
            var assetTypeExpr = GetAssetTypeExpr(group.Key);
            var orderedDocs = group.Docs.OrderBy(d => d.Name).ToList();

            writer.WriteLine();
            writer.WriteLine($"    public static class {pluralName}");
            writer.WriteLine("    {");

            // Properties with private setters
            foreach (var doc in orderedDocs)
            {
                var fieldName = ToPascalCase(doc.Name);
                writer.WriteLine($"        public static {runtimeType} {fieldName} {{ get; private set; }} = null!;");
            }

            // Load method
            writer.WriteLine();
            writer.WriteLine("        public static void Load()");
            writer.WriteLine("        {");
            foreach (var doc in orderedDocs)
            {
                var fieldName = ToPascalCase(doc.Name);
                writer.WriteLine($"            {fieldName} = ({runtimeType})Asset.Load({assetTypeExpr}, Names.{fieldName})!;");
            }
            writer.WriteLine("        }");

            // Unload method
            writer.WriteLine();
            writer.WriteLine("        public static void Unload()");
            writer.WriteLine("        {");
            foreach (var doc in orderedDocs)
            {
                var fieldName = ToPascalCase(doc.Name);
                writer.WriteLine($"            {fieldName}?.Dispose();");
            }
            writer.WriteLine("        }");

            writer.WriteLine("    }");
        }

        // Palettes class with expanded colors
        var palettes = PaletteManager.Palettes;
        if (palettes.Count > 0)
        {
            writer.WriteLine();
            writer.WriteLine("    public static class Palettes");
            writer.WriteLine("    {");

            for (int p = 0; p < palettes.Count; p++)
            {
                var palette = palettes[p];
                var paletteName = ToPascalCase(palette.Id);

                if (p > 0) writer.WriteLine();
                writer.WriteLine($"        public static class {paletteName}");
                writer.WriteLine("        {");

                var usedNames = new HashSet<string>();
                for (int c = 0; c < palette.Count; c++)
                {
                    var color = palette.Colors[c];
                    var r = (byte)(color.R * 255f);
                    var g = (byte)(color.G * 255f);
                    var b = (byte)(color.B * 255f);
                    var a = (byte)(color.A * 255f);

                    var colorName = palette.ColorNames[c];
                    var fieldName = !string.IsNullOrEmpty(colorName)
                        ? ToPascalCase(colorName)
                        : $"Color{c}";

                    // Handle duplicate names by appending index
                    if (!usedNames.Add(fieldName))
                        fieldName = $"{fieldName}{c}";

                    writer.WriteLine($"            public static readonly Color {fieldName} = new({r}, {g}, {b}, {a});");
                }

                writer.WriteLine("        }");
            }

            writer.WriteLine("    }");
        }

        // AtlasArray field if we have atlases
        if (hasAtlases)
        {
            writer.WriteLine();
            writer.WriteLine("    public static Texture? AtlasArray { get; private set; }");
        }

        // LoadAssets method
        writer.WriteLine();
        writer.WriteLine("    public static void LoadAssets()");
        writer.WriteLine("    {");
        foreach (var group in documentsByType)
        {
            var pluralName = Pluralize(GetAssetTypeName(group.Key));
            writer.WriteLine($"        {pluralName}.Load();");
        }

        // Create texture array from atlases
        if (hasAtlases)
        {
            var atlasGroup = documentsByType.First(g => g.Key == AssetType.Atlas);
            var atlasNames = atlasGroup.Docs.OrderBy(d => d.Name).Select(d => $"Atlases.{ToPascalCase(d.Name)}").ToList();

            writer.WriteLine();
            writer.WriteLine("        // Create texture array from all atlases");
            writer.WriteLine($"        AtlasArray = Texture.CreateArray(\"SpriteAtlas\",{string.Join(", ", atlasNames)});");
            writer.WriteLine("        Graphics.SpriteAtlas = AtlasArray;");
        }

        writer.WriteLine("    }");

        // ReloadAssets method
        writer.WriteLine();
        writer.WriteLine("    public static void ReloadAssets()");
        writer.WriteLine("    {");
        writer.WriteLine("        // TODO: hot reload");
        writer.WriteLine("    }");

        // UnloadAssets method
        writer.WriteLine();
        writer.WriteLine("    public static void UnloadAssets()");
        writer.WriteLine("    {");

        // Dispose AtlasArray first
        if (hasAtlases)
        {
            writer.WriteLine("        Graphics.SpriteAtlas = null;");
            writer.WriteLine("        AtlasArray?.Dispose();");
            writer.WriteLine("        AtlasArray = null;");
        }

        foreach (var group in documentsByType)
        {
            var pluralName = Pluralize(GetAssetTypeName(group.Key));
            writer.WriteLine($"        {pluralName}.Unload();");
        }
        writer.WriteLine("    }");

        writer.WriteLine("}");

        Log.Info($"Generated {path}");
    }

    private static void GenerateLua(EditorConfig config)
    {
        var path = config.GenerateLua!;
        var className = config.LuaClass;

        Directory.CreateDirectory(Path.GetDirectoryName(path) ?? ".");

        using var writer = new StreamWriter(path);

        writer.WriteLine("--");
        writer.WriteLine("--  Auto-generated by NoZ Editor - DO NOT EDIT");
        writer.WriteLine("--");
        writer.WriteLine();
        writer.WriteLine($"local {className} = {{}}");
        writer.WriteLine();

        var manifestEntries = GetManifestEntries();
        var documentsByType = manifestEntries
            .GroupBy(e => e.Type)
            .OrderBy(g => g.Key.ToString())
            .Select(g => new { Key = g.Key, Docs = g.Select(e => e.Doc).ToList() })
            .ToList();

        foreach (var group in documentsByType)
        {
            var typeName = GetAssetTypeName(group.Key);
            var pluralName = Pluralize(typeName);
            writer.WriteLine($"{className}.{pluralName} = {{");

            foreach (var doc in group.Docs.OrderBy(d => d.Name))
            {
                var constName = ToPascalCase(doc.Name);
                writer.WriteLine($"    {constName} = \"{doc.Name}\",");
            }

            writer.WriteLine("}");
            writer.WriteLine();
        }

        writer.WriteLine($"return {className}");

        Log.Info($"Generated {path}");
    }

    private static string ToPascalCase(string name)
    {
        var sb = new System.Text.StringBuilder();
        var capitalizeNext = true;

        foreach (var c in name)
        {
            if (c == '_' || c == '-' || c == ' ')
            {
                capitalizeNext = true;
            }
            else if (capitalizeNext)
            {
                sb.Append(char.ToUpperInvariant(c));
                capitalizeNext = false;
            }
            else
            {
                sb.Append(c);
            }
        }

        return sb.ToString();
    }

    private static string ToCSharpIdentifier(string name)
    {
        var sb = new System.Text.StringBuilder();
        var capitalizeNext = true;

        foreach (var c in name)
        {
            if (c == '_' || c == '-' || c == ' ')
            {
                capitalizeNext = true;
            }
            else if (char.IsLetterOrDigit(c))
            {
                if (capitalizeNext)
                {
                    sb.Append(char.ToUpperInvariant(c));
                    capitalizeNext = false;
                }
                else
                {
                    sb.Append(c);
                }
            }
        }

        var result = sb.ToString();

        // Ensure identifier doesn't start with a digit
        if (result.Length > 0 && char.IsDigit(result[0]))
            result = "_" + result;

        // Handle empty result
        if (string.IsNullOrEmpty(result))
            result = "_";

        return result;
    }
}
